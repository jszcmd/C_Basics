// 枚举(Enumeration)：一一列举所有可能的取值
// 枚举常量：定义在枚举类型中的标识符都是常量
// 枚举的作用：将一组相关的整型常量组织在一起，提高代码可读性
// 适用场景：如一周中的星期一到星期天、颜色、状态码等可以一一列举的值
//

// #####################################################################
// 1. 枚举类型的定义
// #####################################################################

// 枚举类型的声明和基本使用

#include <stdio.h>

// 定义枚举类型 - 描述一周的星期
enum Weekday
{
    MONDAY,    // 星期一 -- 默认的值是从0开始
    TUESDAY,   // 星期二 -- 自动递增，值为1
    WEDNESDAY, // 星期三 -- 自动递增，值为2
    THURSDAY,  // 星期四 -- 自动递增，值为3
    FRIDAY,    // 星期五 -- 自动递增，值为4
    SATURDAY,  // 星期六 -- 自动递增，值为5
    SUNDAY,    // 星期天 -- 自动递增，值为6
};

int main1()
{
    enum Weekday d5 = FRIDAY;  // 定义一个枚举变量d5，表示星期五
    printf("%d\n", MONDAY);    // 输出：0 - MONDAY对应的整数值
    printf("%d\n", TUESDAY);   // 输出：1 - TUESDAY对应的整数值
    printf("%d\n", WEDNESDAY); // 输出：2 - WEDNESDAY对应的整数值
    return 0;
}

// 如果需要自定义枚举的起始值，可以显式赋值

#include <stdio.h>

// 定义枚举类型，创建了一个新的数据类型
// 注意：枚举类型的声明本身不占用内存空间
enum Weekday
{
    // 下面的都是枚举常量，一旦定义就不能修改
    MONDAY = 1, // 星期一 -- 显式指定值为1
    TUESDAY,    // 星期二 -- 自动递增，值为2
    WEDNESDAY,  // 星期三 -- 自动递增，值为3
    THURSDAY,   // 星期四 -- 自动递增，值为4
    FRIDAY,     // 星期五 -- 自动递增，值为5
    SATURDAY,   // 星期六 -- 自动递增，值为6
    SUNDAY,     // 星期天 -- 自动递增，值为7
};

int main2()
{
    enum Weekday d5 = FRIDAY; // 创建枚举变量时才分配内存空间
    // enum Weekday d5 = 5;   // 在C语言中这样赋值语法上不会报错，但破坏了类型安全
    // 在C++中这样的赋值会有问题，因为C++对枚举的类型检查更严格

    printf("%d\n", MONDAY);    // 输出：1
    printf("%d\n", TUESDAY);   // 输出：2
    printf("%d\n", WEDNESDAY); // 输出：3
    printf("%d\n", THURSDAY);  // 输出：4
    printf("%d\n", FRIDAY);    // 输出：5
    printf("%d\n", SATURDAY);  // 输出：6
    printf("%d\n", SUNDAY);    // 输出：7
    printf("%d\n", d5);        // 输出：5 - 变量d5的值
    return 0;
}

// 注意：并不是所有的数据类型都适合用枚举
// 比如身高这种连续的范围值就不适合枚举，因为无法一一列举所有可能的值

// #####################################################################
// 2. 枚举的优点
// #####################################################################

// 枚举相比于#define定义常量的优势

// 使用#define预处理指令定义常量
#define Mon 1
#define Tues 2
// #define是简单的文本替换，在预处理阶段完成

int main3()
{
    int m = Mon; // 预处理后变为：int m = 1;
    return 0;
}

// 编译过程的各个阶段：
// 源文件 → (预处理) → 编译 → 链接 → 可执行文件(.exe)
//        ↑          ↑
//    #define替换   调试时针对的是这个阶段
//
// 预处理阶段：会把所有的Mon都替换成1
// 如果是 int m = Mon; 预处理后都会变成 int m = 1;
// 调试的时候，调试器看到的代码中已经没有Mon标识符，只有数字1
// 这样就失去了原始代码的语义信息

// 但是枚举调试的时候不一样：
// 枚举不是简单的文本替换，它在编译阶段处理
// 调试的时候依然可以观察到枚举常量的名称，保持了代码的可读性

// 枚举相比于#define的主要优点：
// 1. 增加了代码的可读性 - 使用有意义的名称代替魔术数字
// 2. 和#define定义的标识符比较，枚举有类型检查，更加严谨
// 3. 防止了命名的污染(封装) - 枚举常量有自己的作用域
// 4. 便于调试 - 调试器可以显示枚举常量的名称
// 5. 使用方便 - 一次可以定义多个相关的变量，支持自动递增

// #####################################################################
// 3. 枚举的使用
// #####################################################################

// 枚举类型的具体使用示例

// 定义颜色枚举，使用不连续的值
enum Color
{
    RED = 1,   // 红色 - 值为1
    GREEN = 2, // 绿色 - 值为2
    BLUE = 4,  // 蓝色 - 值为4（可以使用2的幂次方，便于位操作）
};

// 枚举变量的定义和赋值
enum Color clr = GREEN; // 正确的用法：使用枚举常量给枚举变量赋值
                        // 这样可以保持类型的匹配和一致性

// clr = 5; // 这样可以吗？？？
//
// 回答：在C语言中语法上是允许的，但是不推荐这样做
// 原因：
// 1. 破坏了类型安全 - 5不是enum Color中定义的值
// 2. 降低了代码的可读性 - 数字5没有明确的语义
// 3. 不利于代码维护 - 如果枚举定义改变，这样的赋值可能产生错误
//
// 正确的做法应该是：clr = BLUE;  // 使用枚举常量赋值
