// 联合(共用体) - Union Type
// 用途：多个成员变量共享同一块内存空间，用于节省内存或实现类型转换
// 特点：同一时刻只能使用一个成员，修改一个成员会影响其他成员的值

// #####################################################################
// 1. 联合类型的定义
// #####################################################################

// 联合也是一种特殊的自定义类型
// 这种类型的变量也包含一系列的成员,特征是这些成员共用同一块空间
// 所以联合也叫公用体
// 适用场景：类型转换、硬件寄存器映射、协议解析等需要共享内存的场景

#include <stdio.h>

// 定义联合类型
union Unn
{
    int a;  // 4字节 - 整型数据
    char c; // 1字节 - 字符数据
};
// 节省空间的设计理念：用a的时候不用c,用c的时候不用a，两者共享4字节内存
// 相比结构体（需要4+1=5字节），联合体只需要4字节，节省了1字节空间

// #####################################################################
// 2. 联合的特点
// #####################################################################

// 联合的成员公用一块内存空间,这样一个联合体变量的大小,至少是最大成员的大小
// 因为联合至少得有能力保存最大的那个成员
// 重要特性：所有成员的起始地址都相同，指向同一块内存区域

// 共用特性演示
int main1()
{
    union Unn u; // 联合变量的定义 - 在栈上分配4字节内存

    // 计算整个联合体变量的大小
    printf("联合体大小: %zu\n", sizeof(u)); // 输出: 4 - 共用的体现,大家公用一块空间
    // 说明：虽然有两个成员，但只分配最大成员(int)的大小

    // 验证成员共用同一块内存地址 - 核心特性验证
    printf("联合体u的地址: %p\n", &u);
    printf("成员a的地址: %p\n", &(u.a));
    printf("成员c的地址: %p\n", &(u.c));
    // 可以看到三个地址相同，证明所有成员确实共用同一块内存
    // c占用a的第一个字节（在小端机器上）

    // 演示成员之间的相互影响 - 重要：修改一个成员会影响其他成员
    u.a = 0x11223344;                               // 给整型成员赋值
    printf("设置a为0x11223344后: a = 0x%x\n", u.a); // 输出: 0x11223344

    u.c = 0x00;                               // 修改字符成员（实际上修改了a的最低字节）
    printf("设置c为0x00后: a = 0x%x\n", u.a); // 输出: 0x11223300（小端机器）
    // 关键理解：c对应a的最低字节，修改c就等于修改a的一部分
    // 在小端机器上：c对应a的0x44字节，修改为0x00后a变为0x11223300

    return 0;
}

// #####################################################################
// 3. 联合的实际应用 - 判断大小端
// #####################################################################

// 判断当前机器是大端还是小端存储
// 大小端概念：
// - 小端(Little Endian)：低位字节存储在低地址（Intel/AMD x86架构）
// - 大端(Big Endian)：高位字节存储在低地址（网络字节序、某些RISC处理器）

#include <stdio.h>

// 方法1：使用指针方式判断大小端（传统方法）
// int check_sys(){
//     int a = 1;
//     return *(char*)&a;  // 取a的地址，转换为char指针，解引用得到第一个字节
// }

// 方法2：使用联合体判断大小端（更清晰、类型安全）
int check_sys()
{
    // 这个结构是创建在这个函数里面的栈上的
    // 只用1次就不用了，使用匿名联合体也可以
    union Un
    {
        char c; // 1字节，用于读取int的第一个字节
        int i;  // 4字节，用于存储整型值1
    } u;
    u.i = 1;    // 将整型1存入联合体 - 二进制: 0x00000001
    return u.c; // 通过char成员读取第一个字节（内存最低地址处的字节）
    // 返回1是小端（01 00 00 00），返回0是大端（00 00 00 01）
}

int main2()
{
    int a = 1; // 十六进制: 0x 00 00 00 01
    // 内存布局分析：
    // 低地址 ---------------> 高地址
    // 小端存储: [01] [00] [00] [00] - 低位字节(01)在低地址
    // 大端存储: [00] [00] [00] [01] - 高位字节(00)在低地址

    int res = check_sys();
    if (res == 1)
        printf("小端存储(Little Endian)\n"); // 常见于x86/x64架构
    else
        printf("大端存储(Big Endian)\n"); // 常见于网络字节序、某些嵌入式系统

    return 0;
}

// #####################################################################
// 4. 联合体大小的计算
// #####################################################################

// 联合体大小计算规则：
// (1) 联合的大小至少是最大成员的大小（基础要求）
// (2) 当最大成员大小不是最大对齐数的整数倍时，就要对齐到最大对齐数的整数倍（内存对齐要求）

// 重要理解：联合体的大小不一定是最大成员的大小，可能因内存对齐而更大

#include <stdio.h>

// 示例1：数组成员的对齐计算
union Un
{
    char arr[5]; // 5字节 - 字符数组
    // 这个数组的类型: char [5]
    // 对齐方式理解：可以理解成拆成5个char的类型来计算对齐
    // 相当于: char c1; char c2; char c3; char c4; char c5;
    // char arr[5]是按照char对齐的,对齐数1
    int i; // 4字节 对齐数:4（通常是4字节对齐）
};
// 计算过程：
// - 最大成员大小：5字节（arr[5]）
// - 最大对齐数：4（int的对齐数）
// - 最终大小：8字节（5向上取整到4的倍数）
// 结果：浪费了3个字节的空间用于对齐

// 注意：Un和Un3并不等价，虽然看起来相似但内存布局不同
union Un3
{
    // 这里的5个char成员都共享同一块内存，不是连续的5个字节
    // 实际上c1到c5都指向联合体的起始地址，相当于5个别名
    char c1; // 与c2,c3,c4,c5共享同一字节
    char c2; // 实际上就是c1，只是不同的名字
    char c3; // 实际上就是c1，只是不同的名字
    char c4; // 实际上就是c1，只是不同的名字
    char c5; // 实际上就是c1，只是不同的名字
    int i;   // 4字节 对齐数:4
};
// 计算过程：
// - 最大成员大小：4字节（int i）
// - 最大对齐数：4（int的对齐数）
// - 最终大小：4字节（正好是4的倍数）
// 关键区别：这里只有4字节，5个char成员都指向这4字节中的同一位置

// 示例2：短整型数组的对齐计算
union Un2
{
    short arr[7]; // 14字节 - short类型数组，7个元素×2字节=14字节
    // short对齐数：2（通常short是2字节对齐）
    int i; // 4字节 - 对齐数：4
};
// 计算过程：
// - 最大成员大小：14字节（arr[7]）
// - 最大对齐数：4（int的对齐数）
// - 最终大小：16字节（14向上取整到4的倍数）
// 结果：浪费了2个字节的空间用于对齐

int main()
{
    printf("union Un大小: %zu\n", sizeof(union Un));   // 8 - 含5字节数组+对齐
    printf("union Un2大小: %zu\n", sizeof(union Un2)); // 16 - 含14字节数组+对齐
    printf("union Un3大小: %zu\n", sizeof(union Un3)); // 4 - 只有int大小

    // 验证Un3的特性
    union Un3 u3;
    u3.c1 = 'A';
    printf("c1=%c, c2=%c, c3=%c\n", u3.c1, u3.c2, u3.c3); // 都输出'A'
    // 证明：c1,c2,c3...都指向同一内存位置

    return 0;
}

/*
联合体关键总结：
1. 所有成员共用同一块内存空间 - 核心特性
2. 联合体大小至少是最大成员的大小 - 基础规则
3. 联合体大小需要满足最大对齐数的整数倍 - 内存对齐要求
4. 联合体适合用于类型转换、节省内存、硬件寄存器映射等场景
5. 数组在联合体中对齐时，按元素类型对齐而非数组总大小对齐
6. 修改任一成员会影响其他成员的值 - 使用时要特别注意
7. 同一时刻只能有效使用一个成员 - 设计理念

使用注意事项：
- 读取未最近写入的成员会产生未定义行为
- 适合"要么用A，要么用B，不会同时用"的场景
- 在嵌入式开发中常用于寄存器映射
- 在网络编程中用于协议字段解析
*/
