#define _CRT_SECURE_NO_WARNINGS

// ============================================================
// 3. 字符数组(无\0)的strlen风险分析
// ============================================================
// 题目(3):char arr[] = { 'a','b','c','d','e','f' }; 和strlen
// size_t strlen(const char* str);
/**
 * @function strlen
 * @brief 获取C风格字符串的长度
 *
 * @param str - C风格字符串(以空字符结尾的字符数组)
 * @return size_t - 字符串的长度(不包含终止的空字符)
 *
 * @details
 * - 计算从字符串开头到终止空字符之间的字符数量
 * - 返回值不包括终止空字符本身
 * - 注意：这与字符数组的大小不同
 *
 * @example
 * char mystr[100] = "test string";
 * // sizeof(mystr) 返回 100(数组总大小)
 * // strlen(mystr) 返回 11(实际字符串长度)
 *
 * @note
 * - 在C++中，char_traits::length 实现了相同的行为
 * - 传入的字符串必须以空字符('\0')结尾
 */

// ============================================================

#include <stdio.h>
#include <string.h> // 使用strlen函数

// ============================================================
// 1. 字符数组(无\0)的strlen风险分析
// ============================================================

/// @brief 在GCC编译器上面运行需要把这个main1_VS注释掉;
// int main1_VS()
// {
//     // 定义没有'\0'结尾的字符数组
//     char arr[] = {'a', 'b', 'c', 'd', 'e', 'f'}; // arr的长度为6

//     printf("%zu\n", strlen(arr)); // 大于等于6的随机值，我们假设为X(随机值)
//     // 情况1：对无'\0'结尾的数组使用strlen → 会一直读到内存中出现0为止 → 随机大数

//     printf("%zu\n", strlen(arr + 0)); // X(随机值)
//     // 情况2：arr+0等价于arr,结果相同

//     // ========== 野指针示范 ==========
//     // printf("%zu\n", strlen(*arr)); // 编译错误/运行时错误
//     // 解释：*arr是字符'a'，ASCII值为97
//     // strlen(97)会把97当作内存地址去访问，这是野指针访问 → 必崩！

//     // printf("%zu\n", strlen(arr[1])); // 编译错误/运行时错误
//     // 解释：arr[1]是字符'b'，ASCII值为98
//     // strlen(98)同样会导致野指针访问 → 必崩！

//     // VS编译器可以直接编译通过（类型检查较宽松）：
//     printf("%zu\n", strlen(&arr)); // X(随机值)
//     // 情况3：VS编译器允许char(*)[6]类型自动转换为char*类型
//     // 虽然类型不对，但碰巧指向开头，所以结果和strlen(arr)一样（运气好才对）

//     printf("%zu\n", strlen(&arr + 1)); // X(随机值) - 6
//     // 情况4：跳过整个数组后的地址 → 完全越界 → 未定义行为

//     printf("%zu\n", strlen(&arr[0] + 1)); // X(随机值) - 1
//     // 情况5：从第二个元素开始查找 → 仍然无'\0' → 随机值

//     return 0;
// }

// ============================================================
int main1_GCC()
{
    char arr[] = {'a', 'b', 'c', 'd', 'e', 'f'}; // arr的长度为6

    printf("%zu\n", strlen(arr)); // 大于等于6的随机值

    printf("%zu\n", strlen(arr + 0)); // X(随机值)

    // ========== 野指针示范保留 ==========
    // printf("%zu\n", strlen(*arr)); // 错误：野指针访问
    // printf("%zu\n", strlen(arr[1])); // 错误：野指针访问

    printf("%zu\n", strlen((char *)&arr)); // X(随机值)
    // 情况3：GCC要求显式类型转换

    /// @brief strlen(&arr + 1) 把数组完全结束之后,大小为0的空洞区域当成字符串读取,是典型的越界读取未定义行为
    /// @brief 用 -Wstringop-overread 警告正是指出这一点.所以把下面的代码注释掉了;
    // printf("%zu\n", strlen((char *)(&arr + 1))); // X(随机值) - 6
    // 情况4：跳过整个数组(需要类型转换)

    printf("%zu\n", strlen(&arr[0] + 1)); // X(随机值) - 1
    // 情况5：从第二个元素开始

    return 0;
}

// ============================================================
// 2. 字符串(带\0)的strlen分析
// ============================================================

/// @brief 在GCC编译器上面运行需要把这个main2_VS注释掉;
// int main2_VS()
// {
//     char arr[] = "abcdef"; // arr的实际长度为7

//     printf("%zu\n", strlen(arr)); // 6
//     // 情况1：从数组开头计算字符串长度 → 正确 6

//     printf("%zu\n", strlen(arr + 0)); // 6
//     // 情况2：arr+0等价于arr，结果相同

//     // ========== 野指针示范保留 ==========
//     // printf("%zu\n", strlen(*arr)); // 错误：野指针访问
//     // printf("%zu\n", strlen(arr[1])); // 错误：野指针访问

//     printf("%zu\n", strlen(&arr)); // 6
//     // 情况3：VS允许char(*)[7]自动转换为char*类型 → 碰巧正确（但不推荐）

//     printf("%zu\n", strlen(&arr + 1)); // 随机值
//     // 情况4：跳过整个数组后的地址 → 未定义行为

//     printf("%zu\n", strlen(&arr[0] + 1)); // 5
//     // 情况5：从第二个元素开始计算 → 正确 5

//     return 0;
// }

int main2_GCC()
{
    char arr[] = "abcdef"; // arr的实际长度为7

    printf("%zu\n", strlen(arr)); // 6
    // 情况1：从数组开头 → 6

    printf("%zu\n", strlen(arr + 0)); // 6
    // 情况2：等价于arr

    // ========== 野指针示范保留 ==========
    // printf("%zu\n", strlen(*arr)); // 错误
    // printf("%zu\n", strlen(arr[1])); // 错误

    printf("%zu\n", strlen((char *)&arr)); // 6
    // 情况3：必须显式类型转换

    /// @brief strlen(&arr + 1) 把数组完全结束之后,大小为0的空洞区域当成字符串读取,是典型的越界读取未定义行为
    /// @brief 用 -Wstringop-overread 警告正是指出这一点.所以把下面的代码注释掉了;
    // printf("%zu\n", strlen((char *)(&arr + 1))); // 随机值
    // 情况4：跳过整个数组

    printf("%zu\n", strlen(&arr[0] + 1)); // 5
    // 情况5：从第二个元素开始

    return 0;
}

// ============================================================
// 3. 字符指针的strlen分析
// ============================================================
int main()
{
    char *p = "abcdef"; // 把首元素'a'的地址放入到p里面

    printf("%zu\n", strlen(p)); // 6
    // 情况1：指针p指向字符串开头 → 正确 6

    printf("%zu\n", strlen(p + 1)); // 5
    // 情况2：p+1指向'b' → 剩余5个字符

    // ========== 野指针示范保留 ==========
    // printf("%zu\n", strlen(*p)); // 错误 → *p='a'=97 → 野指针
    // printf("%zu\n", strlen(p[1])); // 错误 → p[1]='b'=98 → 野指针

    // printf("%zu\n", strlen(&p)); // 随机值(VS编译器)―― 也保留说明

    printf("%zu\n", strlen((char *)&p)); // 随机值
    // 情况3：&p是指针变量p本身的地址 → 读取栈上内容 → 完全随机

    /// @brief strlen(&arr + 1) 把数组完全结束之后,大小为0的空洞区域当成字符串读取,是典型的越界读取未定义行为
    /// @brief 用 -Wstringop-overread 警告正是指出这一点.所以把下面的代码注释掉了;
    // printf("%zu\n", strlen((char *)(&p + 1))); // 随机数(和上面不是相差1)
    // 情况4：&p+1跳过指针变量p → 读取栈上下一块内存 → 完全随机

    printf("%zu\n", strlen(&p[0] + 1)); // 5
    // 情况5：等价于p+1 → 正确 5

    return 0;
}
