#define _CRT_SECURE_NO_WARNINGS

// (一).字符指针
// (二).指针数组
// (三).数组指针
// (四).数组传参和指针传参
// (五).函数指针
// (六).函数指针数组
// (七).指向函数指针数组的指针
// (八).回调函数
// (九).指针和数组面试题目的解析

// 前面我们学习了指针的基本概念,指针的定义,指针的使用,指针的运算等内容
// (a):指针就是变量,用来存放地址,地址唯一表示一块内存空间
// (b):指针的大小是固定的4/8个字节(32位平台/64位平台)
// (c):指针是有类型,指针的类型决定了指针+-整数的步长,指针解引用操作的时候的权限
// (d):指针的运算

// #########################################################
// (一):字符指针 (char*)类型的指针
// #########################################################

#include <stdio.h>

int main1()
{
    // 基础字符指针的使用
    char ch = 'w';
    char *pc = &ch;
    // 解释：char* pc 中，*表示pc是一个指针变量，char表示pc指向的数据类型是char
    // pc存储的是变量ch的内存地址
    *pc = 'd';          // 通过指针间接修改ch的值：先通过pc找到ch的内存位置，然后修改该位置的值
    printf("%c\n", ch); // 输出修改后的ch值

    // 字符指针指向字符串常量
    char *p1 = "abcdefg"; // "abcdefg"是一个字符串常量，存储在只读数据区
    // 注意：字符串常量存储在只读区，不能通过指针p1修改字符串内容
    // 这里实际上是将字符串首字符'a'的内存地址赋值给指针变量p1
    printf("%s\n", p1); // 输出整个字符串，从p1指向的位置开始直到遇到'\0'结束

    // 更安全的写法：使用const修饰符
    const char *p = "abcdefg"; // 推荐使用const，防止意外修改字符串常量
    // const char* p 表示p指向的内容是只读的，不能通过p修改字符串
    // "abcdefg"在内存中的布局：'a''b''c''d''e''f''g''\0'
    // 使用const可以避免编译通过但运行时报错的情况

    // 验证字符串常量的内存复用特性
    printf("%p\n", p);  // 打印p指向的地址
    printf("%p\n", p1); // 打印p1指向的地址
    // 通常p和p1的地址值相同，说明编译器对相同的字符串常量进行了内存复用优化

    // 字符数组与字符指针的区别
    char arr[] = "abcdefg"; // 这是字符数组,用字符串常量初始化数组内容
    // 此时"abcdefg"被复制到arr数组中,arr在栈区有独立的内存空间
    // 可以通过下标修改arr数组中的内容:arr[0] = 'x' 是合法的
    printf("%s\n", arr); // 打印字符串

    return 0;
}

// 练习1:深入理解字符串常量与字符数组的地址特性
#include <stdio.h>
int main2()
{
    // 测试字符串常量的内存复用
    const char *p1 = "abcdefg";
    const char *p2 = "abcdefg";
    // 两个指针指向同一个字符串常量
    // 编译器优化:相同的字符串常量在内存中只保存一份副本
    // 因此p1和p2存储的是同一个内存地址

    // 测试字符数组的内存分配
    char arr1[] = "abcdefg";
    char arr2[] = "abcdefg";
    // 两个独立的字符数组，分别在栈区分配内存空间
    // 虽然内容相同，但arr1和arr2占用不同的内存地址
    // 可以通过下标修改各自数组中的内容

    // 比较字符串常量的地址
    if (p1 == p2)
    {
        printf("p1==p2\n"); // 预期输出：两个指针指向同一内存地址
        printf("p1地址:%p\n", p1);
        printf("p2地址:%p\n", p2);
    }
    else
        printf("p1!=p2\n");

    // 比较字符数组的地址
    if (&arr1[0] == &arr2[0]) // gcc编译器不建议直接比较: arr1 == arr2;
    {
        printf("arr1==arr2\n");
    }
    else
    {
        printf("arr1!=arr2\n");          // 预期输出：两个数组地址不同
        printf("arr1首地址:%p\n", arr1); // 数组名在大多数情况下表示数组首元素地址
        printf("arr2首地址:%p\n", arr2);
    }
    // 重要说明:虽然arr1和arr2的地址不同,但字符串内容相同
    // 可以使用strcmp(arr1, arr2) == 0 来比较字符串内容是否相同

    return 0;
}

// #########################################################
// (二):指针数组
// #########################################################

// 指针数组,本质是一个数组，数组元素都是指针;
// 用途:用来存放多个指针的数组容器

// 各种数组类型的定义示例：
// int arr[10]; // 整型数组:包含10个int类型元素的连续内存空间
// char ch[5];  // 字符数组:包含5个char类型元素的连续内存空间

// 指针数组的定义示例：
// int* arr2[6];   // 整型指针数组:包含6个int*类型元素的数组
//                 // 每个数组元素都是一个指向int类型的指针
// char* arr3[5];  // 字符指针数组:包含5个char*类型元素的数组
//                 // 每个数组元素都是一个指向char类型的指针

// 更复杂的指针数组：
// int* arr1[10];   // 一级整型指针数组：存放10个int*指针
// char* arr2[5];   // 一级字符指针数组：存放5个char*指针
// char** arr3[6];  // 二级字符指针数组：存放6个char**指针
//                  // 每个元素都是指向char*指针的指针

// 指针数组的典型应用:模拟二维数组
#include <stdio.h>
int main()
{
    // 定义三个独立的一维整型数组
    int arr1[] = {1, 2, 3, 4, 5}; // 数组1：包含5个整数
    int arr2[] = {2, 3, 4, 5, 6}; // 数组2：包含5个整数
    int arr3[] = {3, 4, 5, 6, 7}; // 数组3：包含5个整数
    // 这三个数组在内存中是独立分配的，可能不连续

    // 创建指针数组，存储三个数组的首地址
    int *p_arr[] = {arr1, arr2, arr3};
    // p_arr是指针数组，包含3个int*类型的元素
    // p_arr[0] = arr1, p_arr[1] = arr2, p_arr[2] = arr3
    // 这样就通过指针数组将三个独立的一维数组组织起来

    // 使用指针数组模拟二维数组的访问方式
    int i = 0;
    int j = 0;
    for (i = 0; i < 3; i++)
    { // 遍历"行"(三个一维数组)
        for (j = 0; j < 5; j++)
        { // 遍历"列"(每个数组的5个元素)
            // 三种等价的访问方式,都访问同一个内存位置:

            // 方式1:数组下标法(最直观)
            // printf("%d ", p_arr[i][j]);

            // 方式2:指针算术法(当前使用的)
            printf("%d ", *(p_arr[i] + j));
            // 解析：p_arr[i] 获取第i个数组的首地址
            //       p_arr[i] + j 计算第j个元素的地址
            //       *(p_arr[i] + j) 解引用获取该地址的值

            // 方式3：完全指针形式
            // printf("%d ", *(*(p_arr + i) + j));
            // 解析：p_arr + i 获取第i个指针的地址
            //       *(p_arr + i) 解引用获取第i个指针的值（即数组首地址）
            //       *(p_arr + i) + j 计算第j个元素的地址
            //       *(*(p_arr + i) + j) 最终解引用获取元素值
        }
        printf("\n"); // 每输出完一个数组换行
    }
    return 0;
}
