#define _CRT_SECURE_NO_WARNINGS

// ============================================================
// sizeof操作符分析合集 - 各种数据类型的sizeof计算
// 本程序系统演示sizeof在不同数据类型和表达式中的行为，重点理解数组名与指针的区别
// ============================================================

// ============================================================
// main1: 整型数组的sizeof分析
// 演示一维整型数组中sizeof的各种用法，理解数组名何时代表整个数组，何时退化为指针
// 测试环境：32位系统指针4字节，64位系统指针8字节
// ============================================================
#include <stdio.h>
int main1()
{
    int a[] = {1, 2, 3, 4}; // 定义包含4个int元素的数组，每个int占4字节

    // 情况1：sizeof(数组名) - 数组名单独出现在sizeof中，表示整个数组
    // 计算整个数组占用的内存空间：4个元素 × 4字节/元素 = 16字节
    // 类型：int[4] 数组类型
    printf("%zu\n", sizeof(a)); // 16

    // 情况2：sizeof(数组名 + 0) - 数组名参与算术运算，退化为首元素地址
    // a+0等价于&a[0]+0，结果是一个int*类型的指针
    // 指针大小在32位系统为4字节，64位系统为8字节
    printf("%zu\n", sizeof(a + 0)); // 4/8

    // 情况3：sizeof(*数组名) - 对首元素地址解引用，得到首元素本身
    // *a等价于a[0]，类型为int，占4字节
    printf("%zu\n", sizeof(*a)); // 4

    // 情况4：sizeof(数组名 + 1) - 数组名退化为指针，指针算术运算
    // a+1指向第二个元素，结果仍是地址类型（int*）
    printf("%zu\n", sizeof(a + 1)); // 4/8

    // 情况5：sizeof(数组元素) - 直接访问数组元素a[1]，类型为int
    printf("%zu\n", sizeof(a[1])); // 4

    // 情况6：sizeof(&数组名) - 取整个数组的地址，得到数组指针int(*)[4]
    // 虽然类型不同，但指针本身的大小仍是4/8字节
    printf("%zu\n", sizeof(&a)); // 4/8

    // 情况7：sizeof(*&数组名) - &和*操作符相互抵消，*&a等价于a
    // 数组名单独出现，表示整个数组
    printf("%zu\n", sizeof(*&a)); // 16

    // 情况8：sizeof(&数组名 + 1) - &a得到数组指针，+1跳过整个数组
    // 指向数组末尾之后的位置，但仍是地址类型（指针）
    printf("%zu\n", sizeof(&a + 1)); // 4/8

    // 情况9：sizeof(&数组元素) - 取单个元素的地址，得到int*指针
    printf("%zu\n", sizeof(&a[0])); // 4/8

    // 情况10：sizeof(&数组元素 + 1) - 首元素地址+1得到第二个元素地址
    // 等价于&a[1]，结果仍是地址类型
    printf("%zu\n", sizeof(&a[0] + 1)); // 4/8
    return 0;
}

// ============================================================
// main2: 字符数组(无\0)的sizeof分析
// 演示字符数组（无结束符）中sizeof的各种用法，特别注意情况8的整型提升
// 对比main3理解字符串与字符数组的区别
// ============================================================
#include <stdio.h>
int main2()
{
    // 使用字符列表初始化，不会自动添加'\0'，数组长度严格为6
    char arr[] = {'a', 'b', 'c', 'd', 'e', 'f'}; // 长度为6的字符数组

    // 情况1：sizeof(数组名) - 数组名单独出现，计算整个字符数组大小
    // 6个char元素 × 1字节/元素 = 6字节
    // 类型：char[6] 数组类型
    printf("%zu\n", sizeof(arr)); // 6

    // 情况2：sizeof(数组名 + 0) - 数组名参与运算退化为char*指针
    // 指针大小：4/8字节
    printf("%zu\n", sizeof(arr + 0)); // 4/8

    // 情况3：sizeof(*数组名) - 解引用得到首字符'a'，char类型占1字节
    printf("%zu\n", sizeof(*arr)); // 1

    // 情况4：sizeof(数组元素) - 直接访问第二个字符'b'，char类型
    printf("%zu\n", sizeof(arr[1])); // 1

    // 情况5：sizeof(&数组名) - 取整个数组地址，得到char(*)[6]数组指针
    // 指针本身大小：4/8字节
    printf("%zu\n", sizeof(&arr)); // 4/8

    // 情况6：sizeof(&数组名 + 1) - 数组指针+1跳过整个数组，结果仍是地址
    printf("%zu\n", sizeof(&arr + 1)); // 4/8

    // 情况7：sizeof(&数组元素 + 1) - &arr[0]得到char*指针，+1指向第二个元素
    printf("%zu\n", sizeof(&arr[0] + 1)); // 4/8

    // 情况8：sizeof(字符 + 1) - 字符参与算术运算会发生整型提升
    // 'a'(char) 先提升为int，再与1(int)相加，结果为int类型
    // 这是C语言整数运算规则，char/short会提升为int再计算
    printf("%zu\n", sizeof(arr[0] + 1)); // 4
    return 0;
}

// ============================================================
// main3: 字符串(带\0)的sizeof分析
// 演示字符串字面量初始化字符数组的sizeof计算，与main2对比理解\0的影响
// 字符串是特殊的字符数组，编译器自动添加结束符
// ============================================================
#include <stdio.h>
#include <string.h>

int main3()
{
    // 使用字符串字面量初始化，编译器会自动在末尾添加'\0'结束符
    // 数组实际包含7个字符：'a','b','c','d','e','f','\0'
    // 类型：char[7] 数组类型
    char arr[] = "abcdef";

    // 情况1：sizeof(数组名) - 计算整个字符串数组大小，包含隐藏的'\0'
    // 6个可见字符 + 1个'\0' = 7字节
    printf("%zu\n", sizeof(arr)); // 7

    // 情况2：sizeof(数组名 + 0) - 数组名退化为char*指针
    printf("%zu\n", sizeof(arr + 0)); // 4/8

    // 情况3：sizeof(*数组名) - 解引用得到首字符'a'，char类型
    printf("%zu\n", sizeof(*arr)); // 1

    // 情况4：sizeof(数组元素) - 第二个字符'b'，char类型
    printf("%zu\n", sizeof(arr[1])); // 1

    // 情况5：sizeof(&数组名) - 取整个数组地址，类型为char(*)[7]数组指针
    printf("%zu\n", sizeof(&arr)); // 4/8

    // 情况6：sizeof(&数组名 + 1) - 跳过整个数组，指向'\0'字符之后的内存位置
    // 虽然越界，但sizeof不计算只推断类型，结果仍是地址类型
    printf("%zu\n", sizeof(&arr + 1)); // 4/8

    // 情况7：sizeof(&数组元素 + 1) - &arr[0]得到char*，+1指向第二个字符地址
    printf("%zu\n", sizeof(&arr[0] + 1)); // 4/8
    return 0;
}

// ============================================================
// main4: 字符指针的sizeof分析
// 演示字符指针变量和各种指针运算的sizeof计算，对比main1-main3理解数组与指针本质区别
// 指针是变量，存储地址；数组名是标识符，代表内存块
// ============================================================
#include <stdio.h>
#include <string.h>
int main4()
{
    // p是栈区的字符指针变量，占用4/8字节空间，存储的是地址
    // 字符串"abcdef\0"存储在只读数据区，p指向该区域的第一个字符
    // 类型：char* 指针类型
    char *p = "abcdef";

    // 情况1：sizeof(指针变量) - 计算指针变量p本身占用的空间
    // 不是计算指向的内容大小，而是变量本身的大小
    printf("%zu\n", sizeof(p)); // 4/8

    // 情况2：sizeof(指针 + 1) - 指针算术运算，p+1指向字符'b'，结果仍是地址类型
    // 指针运算会根据类型调整步长，char*步长为1字节
    printf("%zu\n", sizeof(p + 1)); // 4/8

    // 情况3：sizeof(*指针) - 解引用指针，得到字符'a'，char类型占1字节
    // 注意：不能修改*p的值，因为指向只读区
    printf("%zu\n", sizeof(*p)); // 1

    // 情况4：sizeof(指针[0]) - 数组表示法，p[0]等价于*(p+0)，得到char类型
    // 编译器将数组语法糖转换为指针运算
    printf("%zu\n", sizeof(p[0])); // 1

    // 情况5：sizeof(&指针变量) - 取指针变量的地址，得到char**二级指针
    // 即指向指针p的指针
    printf("%zu\n", sizeof(&p)); // 4/8

    // 情况6：sizeof(&指针变量 + 1) - 二级指针运算，指向p变量之后的内存位置
    // 步长为sizeof(char*)即4/8字节
    printf("%zu\n", sizeof(&p + 1)); // 4/8

    // 情况7：sizeof(&指针[0] + 1) - &p[0]等价于p，+1指向第二个字符'b'的地址
    printf("%zu\n", sizeof(&p[0] + 1)); // 4/8
    return 0;
}

// ============================================================
// main5: 二维数组的sizeof分析
// 演示二维数组中sizeof的各种用法，理解数组名的多层含义、类型推导和内存布局
// 二维数组本质是数组的数组，arr[0]是第一行数组，arr是第一行地址
// ============================================================
#include <stdio.h>
int main5()
{
    // 定义3行4列的二维整型数组，内存连续存储
    // 内存布局：3个一维数组连续存放，每个包含4个int元素（占16字节）
    // 类型：int[3][4] 二维数组类型
    int arr[3][4] = {0};

    // 情况1：sizeof(二维数组名) - 数组名单独出现，计算整个二维数组大小
    // 3行 × 4列 × 4字节 = 48字节
    printf("%zu\n", sizeof(arr)); // 48

    // 情况2：sizeof(二维数组元素) - arr[0][0]是单个int元素
    printf("%zu\n", sizeof(arr[0][0])); // 4

    // 情况3：sizeof(二维数组的行) - arr[0]单独在sizeof中，表示第一行整个一维数组
    // 4个int元素 × 4字节 = 16字节
    // 类型：int[4] 一维数组类型
    printf("%zu\n", sizeof(arr[0])); // 16

    // 情况4：sizeof(行数组名 + 1) - arr[0]不在单独sizeof中，退化为首元素地址
    // arr[0]等价于&arr[0][0]，arr[0]+1等价于&arr[0][1]，结果是指针
    printf("%zu\n", sizeof(arr[0] + 1)); // 4/8

    // 情况5：sizeof(*(行数组名 + 1)) - 对第一行第二个元素地址解引用
    // 得到arr[0][1]的值，类型为int
    printf("%zu\n", sizeof(*(arr[0] + 1))); // 4

    // 情况6：sizeof(二维数组名 + 1) - arr不在单独sizeof中，退化为首行地址
    // arr+1跳过第一行(16字节)，指向第二行的地址
    // 类型：int(*)[4] 行指针
    printf("%zu\n", sizeof(arr + 1)); // 4/8

    // 情况7：sizeof(*(二维数组名 + 1)) - 对第二行地址解引用，得到整个第二行数组
    // 等价于arr[1]，类型为int[4]
    printf("%zu\n", sizeof(*(arr + 1))); // 16

    // 情况8：sizeof(&行数组 + 1) - &arr[0]取第一行地址（行指针），+1得到第二行地址
    printf("%zu\n", sizeof(&arr[0] + 1)); // 4/8

    // 情况9：sizeof(*(&行数组 + 1)) - 对第二行地址解引用，得到整个第二行数组
    printf("%zu\n", sizeof(*(&arr[0] + 1))); // 16

    // 情况10：sizeof(*二维数组名) - 对首行地址解引用，得到第一行整个数组
    // *arr等价于arr[0]，类型为int[4]
    printf("%zu\n", sizeof(*arr)); // 16

    // 情况11：sizeof(越界访问) - sizeof在编译时确定类型大小，不实际访问内存
    // arr[3]的类型是int[4]（通过arr的类型int[3][4]可推断），虽然越界但编译器能确定大小
    // 4个int元素 × 4字节 = 16字节（不生成实际内存访问代码）
    printf("%zu\n", sizeof(arr[3])); // 16

    // 对比说明：
    // int a = 10;
    // sizeof(int);  // 编译时确定类型大小
    // sizeof(a);    // 编译时确定变量类型大小，不读取变量值
    // 同理，sizeof(arr[3])在编译时就能确定类型大小，与是否越界无关
    return 0;
}
