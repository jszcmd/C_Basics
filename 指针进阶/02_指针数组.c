#define _CRT_SECURE_NO_WARNINGS

// (一).字符指针
// (二).指针数组
// (三).数组指针
// (四).数组传参和指针传参
// (五).函数指针
// (六).函数指针数组
// (七).指向函数指针数组的指针
// (八).回调函数
// (九).指针和数组面试题目的解析

// #########################################################
// (二):指针数组
// #########################################################

// 指针数组,本质是一个数组，数组元素都是指针;
// 用途:用来存放多个指针的数组容器

// 各种数组类型的定义示例：
// int arr[10]; // 整型数组:包含10个int类型元素的连续内存空间
// char ch[5];  // 字符数组:包含5个char类型元素的连续内存空间

// 指针数组的定义示例：
// int* arr2[6];   // 整型指针数组:包含6个int*类型元素的数组
//                 // 每个数组元素都是一个指向int类型的指针
// char* arr3[5];  // 字符指针数组:包含5个char*类型元素的数组
//                 // 每个数组元素都是一个指向char类型的指针

// 更复杂的指针数组：
// int* arr1[10];   // 一级整型指针数组：存放10个int*指针
// char* arr2[5];   // 一级字符指针数组：存放5个char*指针
// char** arr3[6];  // 二级字符指针数组：存放6个char**指针
//                  // 每个元素都是指向char*指针的指针

// 指针数组的典型应用:模拟二维数组
#include <stdio.h>
int main()
{
    // 定义三个独立的一维整型数组
    int arr1[] = {1, 2, 3, 4, 5}; // 数组1:包含5个整数
    int arr2[] = {2, 3, 4, 5, 6}; // 数组2:包含5个整数
    int arr3[] = {3, 4, 5, 6, 7}; // 数组3:包含5个整数
    // 这三个数组在内存中是独立分配的,可能不连续

    // 创建指针数组,存储三个数组的首地址
    int *p_arr[] = {arr1, arr2, arr3};
    // p_arr是指针数组,包含3个int*类型的元素
    // p_arr[0] = arr1, p_arr[1] = arr2, p_arr[2] = arr3
    // 这样就通过指针数组将三个独立的一维数组组织起来

    // 使用指针数组模拟二维数组的访问方式
    int i = 0;
    int j = 0;
    for (i = 0; i < 3; i++)
    { // 遍历"行"(三个一维数组)
        for (j = 0; j < 5; j++)
        { // 遍历"列"(每个数组的5个元素)
            // 三种等价的访问方式,都访问同一个内存位置:

            // 方式1:数组下标法(最直观)
            // printf("%d ", p_arr[i][j]);

            // 方式2:指针算术法(当前使用的)
            printf("%d ", *(p_arr[i] + j));
            // 解析：p_arr[i] 获取第i个数组的首地址
            //       p_arr[i] + j 计算第j个元素的地址
            //       *(p_arr[i] + j) 解引用获取该地址的值

            // 方式3:完全指针形式
            // printf("%d ", *(*(p_arr + i) + j));
            // 解析:p_arr + i 获取第i个指针的地址
            //       *(p_arr + i) 解引用获取第i个指针的值(即数组首地址)
            //       *(p_arr + i) + j 计算第j个元素的地址
            //       *(*(p_arr + i) + j) 最终解引用获取元素值
        }
        printf("\n"); // 每输出完一个数组换行
    }
    return 0;
}
