#define _CRT_SECURE_NO_WARNINGS

// (一).字符指针
// (二).指针数组
// (三).数组指针
// (四).数组参数和指针参数
// (五).函数指针
// (六).函数指针数组
// (七).指向函数指针数组的指针
// (八).回调函数
// (九).指针和数组面试题目的解析

// ##########################################################
// (五).函数指针
// ##########################################################

// 概念对比:
// 数组指针 --- 指向数组的指针就是数组指针
// 函数指针 --- 指向函数的指针就是函数指针

// ==========================================================
// (1): 函数地址与函数指针基础
// ==========================================================
#include <stdio.h>

// 函数存储特性：
// 只要函数一定义，函数就有地址
// 函数是存放在代码区的(只读的,不能修改),每一个函数都有一个唯一的地址
int add1(int x, int y)
{
    return x + y;
}

int main1()
{
    // ============ 数组地址相关概念 ============
    int arr[5] = {5};

    // &数组名,取出的是数组的地址
    int (*p)[5] = &arr; // p就是一个数组指针

    // 数组名 vs &数组名 的区别:
    printf("%p\n", arr);  // 数组名:取出数组首元素的地址
    printf("%p\n", &arr); // &数组名:取出整个数组的地址

    // ============ 函数地址相关概念 ============
    // &函数名 --- 取出的是函数的地址(每一个函数都有地址)
    printf("%p\n", &add1); // &函数名:取出函数的地址
    printf("%p\n", add1);  // 函数名:也是函数的地址

    // 重要结论:对于函数来说,&函数名 和 函数名 都是函数的地址

    // ============ 函数指针定义 ============
    // 函数指针的定义:取出函数的地址,把这个地址存放到一个指针变量中
    int (*p1)(int, int) = &add1; // 等价于:int (*p1)(int, int) = add1;

    // 函数指针语法解析：
    // 第一个int    --> 表示函数的返回值是int类型
    // (*p1)       --> 说明p1是一个指针
    // (int,int)   --> 说明p1指向的是一个函数,函数的两个参数都是int类型的
    // int (*p1)(int x, int y) = &add1;  // 参数名可以省略,但类型必须匹配

    // ============ 普通指针用法回顾 ============
    // 函数指针有什么用呢?我们首先看看普通指针的用法
    int a = 10;
    int *p2 = &a;      // p2是一个指针变量,存放的是a的地址
    *p2 = 20;          // 解引用操作,通过指针变量修改a的值
    printf("%d\n", a); // 输出：20

    // ============ 函数指针的多种调用方式 ============
    // 方式1:标准解引用调用
    int res = (*p1)(2, 3); // 对函数指针解引用,找到函数:间接的通过函数指针调用函数

    // 方式2:省略解引用符号
    int res2 = (p1)(3, 3); // 还可以省略解引用操作

    // 方式3:直接调用(最常用)
    int res4 = p1(3, 3); // 还可以省略解引用操作

    // 方式4:多重解引用(语法允许但没必要)
    int res3 = (******p1)(2, 3); // 多重解引用,效果和上面是一样的

    // 注意事项:
    // 要解引用一定要放到()里面,否则会出错
    // int res5 = *p1(2, 3);       // 错误的写法!因为函数调用()优先级高于解引用*

    printf("计算结果：%d\n", res4);

    return 0;
}

// ==========================================================
// (2): 函数指针的实际应用 - 回调函数
// ==========================================================
#include <stdio.h>

// 简单的加法函数
int add2(int x, int y)
{
    return x + y;
}

// 回调函数示例:接收函数指针作为参数
// pf 是函数指针参数,指向一个接收两个int参数、返回int的函数
void calc1(int (*pf)(int, int))
{
    int a = 3;
    int b = 5;
    int res = pf(a, b); // 通过函数指针调用实际函数
    printf("回调函数计算结果：%d\n", res);
}

int main2()
{
    // 将函数地址传递给回调函数
    calc1(&add2);
    return 0;
}

// ==========================================================
// (3): 函数指针与其他指针类型的对比
// ==========================================================
#include <stdio.h>

// 测试函数，用于演示函数指针
int test(const char *str)
{
    printf("恭喜你进入到函数里面了,参数：%s\n", str);
    return 0;
}

int main()
{
    // ============ 各种指针类型对比 ============
    int *arr[4];   // 整型指针数组:数组元素都是int指针
    char *arr2[5]; // 字符指针数组:数组元素都是char指针

    // 我们怎么把arr(首元素的地址存起来)
    int **p2 = arr; // 需要一个二级指针来存放arr(首元素)的地址

    int arr3[10] = {0};    // 一个普通的数组
    int (*pa)[10] = &arr3; // pa就是一个数组指针,指向了一个数组

    char *arr4[6];
    char *(*p3)[6] = &arr4; // p3指向一个数组,数组中的每一个元素都是char*类型的

    // ============ 函数指针操作 ============
    // 函数指针,也是一种指针,是指向函数的指针
    printf("函数地址1:%p\n", &test); // 取出函数的地址
    printf("函数地址2:%p\n", test);  // 函数名就是函数的地址

    // 把函数的地址存放到一个函数指针变量中
    int (*p)(const char *) = test;   // p就是一个函数指针,指向了test函数
    int (*p1)(const char *) = &test; // 也可以加上&符号

    printf("函数指针大小：%zu字节\n", sizeof(&test)); // 4/8  函数指针变量的大小

    // ============ 通过函数指针调用函数 ============
    int res = p("abc"); // 传递的是"abc"中a的地址
    printf("函数返回值：%d\n", res);

    // p和test就是同一回事
    (*p)("acdefg");    // 通过解引用操作调用函数
    (*******p)("abc"); // 多重解引用调用函数

    // 重要特性：
    // *可以写,也可以不写;但是要写的话,必须放到()里面
    return 0;
}

// ==========================================================
// (4): 函数指针高级应用 - 复杂声明解析
// ==========================================================
// 使用typedef定义函数指针类型别名
typedef void (*pf_t)(int); // 把void (*)(int)类型重命名为pf_t

int main4()
{
    // ============ 复杂代码解析1：来自《C陷阱与缺陷》 ============
    (*(void (*)())0)();

    // 逐步解析：
    // void(*p)() --> p是函数指针;把变量名去掉就是类型：void(*)() 函数指针类型
    // p是一个函数指针,p指向的函数参数是void,返回类型是void
    //
    // (类型) ---> 强制类型转换,把0(int类型)转成函数指针类型
    // (void (*)())0 ---> 把0强制类型转换成:无参,返回类型是void的函数的地址
    //
    // (*函数地址)() ---> 调用函数
    //
    // 上面的代码是一次函数调用,调用的是0作为地址的函数：
    // 1. 把0强制类型转换成:无参,返回类型是void的函数的地址
    // 2. 调用0地址处的这个函数

    // ============ 复杂代码解析2：函数声明分析 ============
    // 函数的声明:
    // int add(int, int);           // 函数声明
    // 函数的声明可以不写参数名，只要写参数类型就可以
    // 也可以写参数名：int add(int x, int y);

    void (*signal(int, void (*)(int)))(int);

    // 复杂声明解析:
    // signal 是一个函数名
    // signal是一个函数名,signal函数的第一个参数类型是int类型,
    // 第二个参数类型是函数指针类型,该函数指针指向的函数参数是int类型,返回类型是void

    // 如果signal是函数指针,那么就要写成 (*signal)(int, void(*)(int))
    // signal一定是函数名,signal(int类型, 函数指针类型)

    // void (* )(int) ---> signal最后的返回类型也是一个函数指针类型
    // 以上代码是一次函数声明,声明的signal的第一个参数类型是int，
    // 第二个参数类型是函数指针类型,该函数指针指向的函数是int类型,返回类型是void
    // signal函数的返回类型也是一个函数指针,该函数指向的函数参数是int,返回类型是void

    // ============ 使用typedef简化复杂声明 ============
    // typedef void(*pf_t)(int);  // 把void (*)(int)类型重命名为pf_t
    // 把上面的signal函数声明简化:
    pf_t signal(int, pf_t); // 简化后的声明,可读性大大提高

    return 0;
}
