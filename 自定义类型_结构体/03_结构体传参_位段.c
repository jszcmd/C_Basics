#define _CRT_SECURE_NO_WARNINGS

// 自定义类型:结构体,枚举,联合

// 结构体:
// 结构体类型的声明
// 结构体的自引用
// 结构体变量的定义和初始化
// 结构体内存对齐
// 结构体的传参
// 结构体实现位段(位段的填充&可移植性)

// #####################################################################
// (5):结构体传参
// #####################################################################

#include <stdio.h>

struct MyStruct
{
	int data[1000];
	int num;
};

// 传值调用
// 形参s会创建一个新的结构体变量,并把实参的值拷贝过来
void print1(struct MyStruct s)
{
	// 传值调用,会拷贝整个结构体,效率低
	int i = 0;
	for (i = 0; i < 10; i++)
	{
		printf("%d ", s.data[i]);
	}
	printf("\n");
}

// 传地址调用
// 使用const修饰形参,表示指针指向的数据不允许被修改(更加安全)
void print2(const struct MyStruct *ps)
{
	// 传地址调用,只传递一个指针,效率高
	int i = 0;
	for (i = 0; i < 10; i++)
	{
		printf("%d ", ps->data[i]);
	}
	printf("\n");
}

// 上面两种传参:
// 首选传地址调用,效率高
// 函数传递的时候,参数时需要压栈,会有时间和空间的开销
// 如果传递的是一个结构体对象的时候,结构体过大,参数压栈的系统开销就更大,会导致性能下降

int main()
{
	struct MyStruct s1 = {{100, 100}, 10};
	print1(s1);	 // 传值调用
	print2(&s1); // 传地址调用
	return 0;
}

/*
结构体传参要点总结:
1. 传值调用:
   - 创建结构体的完整副本
   - 内存开销大,效率低
   - 不会修改原结构体数据

2. 传地址调用:
   - 只传递指针,内存开销小
   - 效率高,适合大型结构体
   - 使用const修饰可保证数据不被修改
   - 推荐使用这种方式

3. 选择原则:
   - 对于大型结构体,始终使用指针传递
   - 如果函数不需要修改结构体,使用const指针
   - 只有对小型结构体且需要副本时才考虑值传递
*/

// #####################################################################
// (6):结构体实现位段 (Bit Fields)
// #####################################################################

// 什么是位段:
// 位就是比特位,位段是可以用来节省空间的
// 位段的声明和结构体是类似的,有两个不同
// 1.位段的成员变量后面有一个冒号(:),后面跟着一个数字,表示该成员变量占用的位数
// 2.位段的成员变量只能是整型家族的(int,unsigned int,signed int,char),不能是浮点型类型
// 位段只能在结构体里面使用

// 位段的内存分配:
// 1.位段的成员可以是:int,unsigned int,signed int,char类型
// 2.位段的空间上是按照以4个字节(int)或者1个字节(char)的方式来开辟的
// 3.位段涉及很多不确定因素,位段是不跨平台的,注重可移植性的程序应该避免使用位段

// 位段的类型一般是统一类型的

#include <stdio.h>

// int类型位段示例 - 用于存储各种配置标志和小的数值
struct A
{
	// int 先开辟4个字节 -- 32个比特位
	int _a : 2; // 只需要分配2个比特位,可以表示0~3之间的数字
	int _b : 5;
	int _c : 10;
	// 再开辟4个字节 -- 32个比特位
	int _d : 30;
	int flag : 1; // 拿flag表示真假
				  // 1表示真,0表示假
}; // 48个比特位 = 6字节

int main1()
{
	printf("%zu\n", sizeof(struct A)); // 8
	return 0;
}

#include <stdio.h>

// char类型位段示例 - 用于紧凑存储多个小范围数值
// :后面的数字表示该成员变量占用的位数,是不能超过该类型的位数的
struct s
{
	// 先按照char类型来分配内存,每次分配1个字节(8个比特位)
	char a : 3; // 占用3个比特位,char有符号位,能表示-4~3之间的数字
	char b : 4; // 占用4个比特位,char有符号位,能表示-8~7之间的数字
	// 前面的剩下的一个比特位没有用
	// 这里还剩下1个比特位,但是下一个成员变量c需要5个比特位,所以需要重新分配1个字节
	char c : 5; // 占用5个比特位,char有符号位,能表示-16~15之间的数字
	// 重新分配1个字节
	char d : 4; // 占用4个比特位,char有符号位,能表示-8~7之间的数字
};

int main2()
{
	printf("%zu\n", sizeof(struct s)); // 3
	struct s s1 = {0};
	s1.a = 10; // 10的二进制是1010,a只能存3个比特位,所以存储的是010,也就是2
	s1.b = 12; // 12的二进制是1100,b只能存4个比特位,所以存储的是1100,也就是-4
	s1.c = 3;  // 3的二进制是00011,c能存5个比特位,所以存储的是00011,也就是3
	s1.d = 4;  // 4的二进制是00100,d只能存4个比特位,所以存储的是0100,也就是4
	// 00000000 00000000 00000000
	// 01100010 00000011 00000100  内存中的存储情况
	// 6    2     0   3   0   4
	printf("%d %d %d %d\n", s1.a, s1.b, s1.c, s1.d);
	return 0;
}

// ### 2.3 位段的跨平台问题
//
//  1. int 位段被当成有符号数还是无符号数是不确定的
//  VS编译器当成有符号数,GCC编译器当成无符号
//  2. 位段中最大位的数目不能确定. (16位机器最大16,32位机器最大32,写成27,在16位机器会出问题)
//  3. 位段中的成员在内存中从左向右分配，还是从右向左分配标准尚未定义。
//  VS编译器是从右向左分配,GCC编译器是从左向右分配
//  4. 当一个结构包含两个位段,第二个位段成员比较大,无法容纳于第一个位段剩余的位时,是舍弃剩余的位还是利用,这是不确定的
//  VS编译器是舍弃剩余的位,GCC编译器是利用剩余的位

/*
位段使用详细说明:

内存分配机制:
- int类型位段: 每次分配4字节(32位)，当前分配块不够用时重新分配4字节
- char类型位段: 每次分配1字节(8位)，当前分配块不够用时重新分配1字节
- 分配单位内成员从右向左(VS)或从左向右(GCC)排列

数值范围限制:
- 无符号n位: 0 到 2^n - 1
- 有符号n位: -2^(n-1) 到 2^(n-1)-1
- 赋值超出范围时会发生位截断

使用注意事项:
1. 不能对位段成员取地址(&操作符)，因为位段没有独立的地址
2. 位段成员不能是数组，不能作为函数参数传递(需要先复制到普通变量)
3. 位段的实际内存布局依赖于编译器和平台
4. 调试时难以直接观察位段成员的值

适用场景:
- 嵌入式系统内存优化
- 协议字段解析(如TCP/IP头)
- 硬件寄存器映射
- 存储大量布尔标志或枚举值

跨平台兼容性建议:
1. 避免在需要跨平台的项目中使用位段
2. 如必须使用，添加详细的平台相关注释
3. 使用编译时断言检查位段大小是否符合预期
4. 考虑使用位操作函数替代位段以提高可移植性
*/
