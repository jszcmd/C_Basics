#define _CRT_SECURE_NO_WARNINGS

// 自定义类型:结构体,枚举,联合

// 结构体:
// 结构体类型的声明
// 结构体的自引用
// 结构体变量的定义和初始化
// 结构体内存对齐
// 结构体的传参
// 结构体实现位段(位段的填充&可移植性)

// #####################################################################
// (1):结构体类型的声明
// #####################################################################

// 数组：一组相同类型元素的集合
// 结构体：一组不同类型元素的集合

// 结构体也叫做结构体
// 结构体是一些值的集合,这些值称为成员变量
// 结构体的每一个成员可以是不同类型的变量

// 结构体的定义方式1：先声明类型，再定义变量
// 这个只是我们定义了一种新的数据类型，并没有分配内存，所以没有初始化
struct Student
{
	// 描述学生的相关属性
	char name[20]; // 姓名
	int age;	   // 年龄
	float score;   // 成绩
} s1, s2;		   // 这里可以同时定义全局变量s1, s2

// 结构体的定义方式2：声明同时定义变量
// 我们也可以在定义结构体的同时定义结构体变量
struct Student2
{
	// 描述学生的相关属性
	char name[20]; // 姓名
	int age;	   // 年龄
	float score;   // 成绩
} s3, s4;		   // 这里的分号不能丢

// 创建的s3和s4是全局变量，如果在函数体内定义就是局部变量
// s3和s4是利用上面的结构体类型定义的变量，也叫做结构体变量

int main1()
{
	// 使用struct Student类型创建一个结构体变量s5
	struct Student s5; // 局部变量
	return 0;
}

// 特殊的声明：匿名结构体类型
// 匿名结构体类型，只能用一次
struct
{
	char name[20]; // 姓名
	int age;	   // 年龄
} s6;
// 声明结构体的时候，创建一个结构体变量s6
// 这种方式定义的结构体类型没有名字，只能用来定义s6这个变量，不能再定义其他变量

// 定义一个匿名结构体，里面有int a; char b; float c;
struct
{
	int a;
	char b;
	float c;
} x;

// 定义匿名结构体数组和指针
struct
{
	int a;
	char b;
	double c;
} arr[20], *ptr;
// 定义了一个匿名结构体类型的数组arr，包含20个元素，每个元素都是一个结构体变量
// 定义了一个指向匿名结构体类型的指针ptr，可以指向数组arr中的元素

int main2()
{
	ptr = &x;
	// warning C4133: "=": 从"*"到"*"的类型不兼容
	// 这样是非法的，因为ptr指向的结构体类型和x的结构体类型不一样
	// 尽管两个结构体的成员看起来相似，但编译器认为它们是不同的类型
	return 0;
}

/*
结构体声明要点总结：
1. 结构体声明只是定义类型，不分配内存
2. 可以在声明时直接定义变量（全局或局部）
3. 匿名结构体只能使用一次，适合特定场景
4. 即使成员相同，不同的结构体类型也被视为不兼容的类型
5. 结构体提供了将不同类型数据组织在一起的机制
*/

// #####################################################################
// (2):结构体的自引用
// #####################################################################

// 数据结构：数据在内存中的存储结构
// 线性数据结构：顺序表，链表
// 树形数据结构：二叉树等...

// 错误的自引用方式 ?
// 这样定义是错误的
// struct Node_error
//{
//    int data;              // 存放一个int类型的数据
//    struct Node_error next; // 存放下一个节点 - 错误：不能包含自身
//    // 问题：这会导致结构体大小无限大，因为next又包含next...
//};

// 正确的自引用方式 ?
// 结构体自己能找到与自己同类型的结构体：
struct Node
{
	// 数据域
	int data; // 存放一个int类型的数据
	// 指针域
	struct Node *next; // 指向下一个节点的指针
					   // 正确：使用指针，只占用固定大小的内存（指针的大小）
};

// 错误的typedef使用方式 ?
// 这样对这个匿名结构体类型起了一个别名叫Node是不行的
/*
typedef struct {
	int data;
	Node* next;  // 错误：此时Node还未定义完成
} Node; // 对这个匿名结构体类型起了一个别名叫Node

int main() {
	printf("%zu\n",sizeof(Node));
	// 语法错误: 标识符"Node"
	return 0;
}
*/

// 正确的typedef使用方式 ?
#include <stdio.h>

// 定义结构体并同时起别名
typedef struct Node
{
	int data;
	struct Node *next; // 这里仍然要用 struct Node*
} Node, *linkList;

/*
这个的意思就是：
struct Node {
	int data;
	struct Node* next;  // 这里仍然要用 struct Node*
};

typedef struct Node Node;
typedef struct Node* linkList;
linkList 就是 struct Node* 的别名
*/

int main()
{
	printf("int类型大小: %zu字节\n", sizeof(int));
	printf("Node结构体大小: %zu字节\n", sizeof(Node));
	return 0;
}

/*
自引用关键点总结：
1. 结构体自引用必须使用指针，不能直接包含同类型变量
2. 使用指针可以避免无限嵌套和内存浪费
3. typedef定义别名时要注意定义顺序，不能在定义完成前使用别名
4. 在结构体定义内部，仍需使用完整的struct Node*形式
5. 自引用是构建链表、树等动态数据结构的基础
*/
