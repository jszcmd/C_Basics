// #########################################################################
// 1. 为什么存在动态内存管理?
// #########################################################################
//
// 我们已经掌握的内存开辟方式有：
// int val = 20;                    // 在栈空间上开辟四个字节
// char arr[10] = {0};              // 在栈空间上开辟10个字节的连续空间
//
// 但是上述静态内存分配的局限性:
// 1. 空间开辟大小是固定的,无法调整
// 2. 数组在声明时必须指定长度,内存在编译时分配
// 3. 申请到的空间不能改变,缺乏灵活性
//
// 动态内存管理的必要性:
// 1. 程序运行时常需要根据实际情况确定空间大小
// 2. 静态内存分配无法满足运行时确定大小的需求
// 3. 需要让程序员能够自主维护和分配内存空间
// 4. 提供了更灵活的内存管理方式
//
// 因此,当静态内存分配无法满足需求时,就需要使用动态内存开辟

// #########################################################################
// 2.动态内存函数 - (1)malloc
// #########################################################################

#include <stdlib.h> // malloc 函数所在的头文件

/*
 * 函数:malloc  在返回之前,这块内存空间都是随机值
 * 功能:分配指定大小的内存块
 * 参数:
 *     size_t size - 内存块的大小,以字节为单位
 *                 - size_t 是无符号整数类型
 * 返回值:
 *     成功:返回指向分配的内存块起始位置的 void* 类型指针
 *           该指针可以强制转换为所需的数据指针类型以便解引用
 *     失败:返回空指针 (NULL)
 * 注意事项：
 *     1. 新分配的内存块内容不会被初始化,其值不确定
 *     2. 如果 size 为零,返回值取决于具体的库实现
 *        (可能是空指针,也可能不是),但返回的指针不能被解引用
 */

#include <stdio.h>
#include <errno.h>  // errno变量的使用
#include <string.h> // strerror函数的头文件
#include <stdlib.h> // malloc
#include <limits.h> // INT_MAX

// INT_MAX; 整型最大值

// ############################
// 内存区域说明
// ############################

// 栈区:局部变量,形式参数,等等,栈区申请的空间大小是不能随便改变的
// 堆区:malloc,calloc,realloc,free操作的空间,malloc申请的空间在堆区

// 变长数组说明:
// 变长数组,并不是这个数组的长度可变;
// 而是说它这个数组在指定它的大小的时候可以用变量;
// C99标准支持变长数组;

// ############################
// malloc 基本使用示例
// ############################

int main1()
{
    // 传统数组 - 固定大小
    // int arr[10] = {0};

    // 变长数组 - C99标准支持
    int n = 0;
    scanf("%d", &n);
    int arr2[n];

    // 动态内存开辟 - 更灵活的内存管理
    int *p = (int *)malloc(40);
    // int* p = (int*)malloc(INT_MAX); // 极端情况测试

    if (p == NULL)
    { // 开辟内存失败
        printf("%s\n", strerror(errno));
        return 1; // 不正常返回
    }

    // 能够走到这,表示空间开辟才成功
    // 使用分配的内存
    int i = 0;
    for (i = 0; i < 10; i++)
    {
        *(p + i) = i;
    }

    // 打印结果
    for (i = 0; i < 10; i++)
    {
        printf("%d ", *(p + i));
    }

    // 内存管理说明:
    // 这里我们没有使用free;
    // 并不是说内存空间不回收了;
    // 当程序退出的时候,系统会自动回收内存空间;

    // 内存泄露概念:
    // 我分配给你一块空间,你用完了,但是你还没有还;
    // 那么这块空间别人也用不了

    // 正确的内存释放:
    free(p);  // p还是指向一个内存地址,
    p = NULL; // 让他再也找不到p指向的内存

    // 错误写法:
    // free(p = NULL); // 这样是不对的;

    return 0; // 表示正常返回
}

// ##################################
// 错误示范:内存泄露示例
// ##################################

// 电脑开辟到一定空间就不开辟了;
// 不建议尝试;
// int main(){
//     while(1){
//         malloc(1); // 持续申请内存但不释放
//     }
//     return 0;
// }

// ##################################
// malloc 实际应用示例:随机字符串生成器
// ##################################

/* malloc example: random string generator*/
#include <stdio.h>  /* printf, scanf, NULL */
#include <stdlib.h> /* malloc, free, rand */

int main()
{
    int i, n;
    char *buffer;

    printf("How long do you want the string? ");
    scanf("%d", &i);

    buffer = (char *)malloc(i + 1); // 多申请一个空间存放'\0'
    if (buffer == NULL)
        exit(1);

    for (n = 0; n < i; n++)
        buffer[n] = rand() % 26 + 'a';
    buffer[i] = '\0';

    printf("Random string: %s\n", buffer);
    free(buffer);

    return 0;
}

// #########################################################################
// 2.动态内存函数 - (2)free
// #########################################################################

#include <stdlib.h> // free 函数所在的头文件

/*
 * 函数：free
 * 功能：释放之前动态分配的内存块
 * 参数：
 *     void* ptr - 指向之前由malloc、calloc或realloc分配的内存块的指针
 * 返回值：
 *     无
 * 注意事项：
 *     1. 只能释放由malloc、calloc或realloc函数分配的内存块
 *     2. 如果ptr不是指向动态分配的内存块，会导致未定义行为
 *     3. 如果ptr是空指针，函数不执行任何操作
 *     4. 该函数不会改变ptr指针本身的值，调用后ptr仍然指向原来的位置（现在已无效）
 *     5. 释放后的内存块可以重新用于后续的内存分配
 */

// #########################################################################
// free 错误使用示例
// #########################################################################

// int main(){
//     int a = 10;
//     int* p = &a;
//     free(p); // p是栈上面的空间,不能释放;会导致未定义行为
//     p = NULL;
//
//     free(NULL); // 不知道要释放谁,什么事情也不干 - 这是安全的
//
//     return 0;
// }

// #########################################################################
// free 正确使用示例
// #########################################################################

/* free example */
#include <stdlib.h> /* malloc, calloc, realloc, free */

int main2()
{
    int *buffer1, *buffer2, *buffer3;
    buffer1 = (int *)malloc(100 * sizeof(int));
    buffer2 = (int *)calloc(100, sizeof(int));
    buffer3 = (int *)realloc(buffer2, 500 * sizeof(int));
    free(buffer1);
    free(buffer3);
    return 0;
}

// #########################################################################
// 2.动态内存函数 - (3):calloc (Contiguous Allocation)
// #########################################################################

#include <stdlib.h> // calloc 函数所在的头文件
#include <stdio.h>  // 输入输出相关函数
#include <errno.h>  // 错误码相关
#include <string.h> // 字符串操作函数

/*
 * 函数: calloc
 * 特点: 在返回之前,会把这一块内存的空间初始化一下,初始化为全0
 * 功能: 分配并初始化指定数量和大小的内存数组
 * 参数:
 *     size_t num  - 要分配的元素个数
 *     size_t size - 每个元素的大小,以字节为单位
 *                 - size_t 是无符号整数类型
 * 返回值:
 *     成功: 返回指向分配的内存块起始位置的 void* 类型指针
 *           该指针可以强制转换为所需的数据指针类型以便解引用
 *     失败: 返回空指针 (NULL)
 * 注意事项:
 *     1. 分配的内存块大小为 (num * size) 字节
 *     2. 分配的内存块所有位都会被初始化为零
 *     3. 如果 size 为零，返回值取决于具体的库实现
 *        (可能是空指针,也可能不是),但返回的指针不能被解引用
 *     4. 适用于需要初始化为零的数组或结构体分配
 */

void calloc_example()
{
    // 内存分配选择指南:
    // 如果你需要初始化,就用calloc；
    // 如果你不需要初始化,就用malloc

    // calloc 特点:在返回内存指针之前,会把整块内存空间初始化为全0
    int *p = (int *)calloc(10, sizeof(int));
    if (p == NULL)
    {
        printf("内存分配失败: %s\n", strerror(errno));
        return;
    }

    // 打印验证初始化结果:
    printf("calloc 分配的内存内容: ");
    int i = 0;
    for (i = 0; i < 10; i++)
    {
        printf("%d ", *(p + i));
    }
    // 预期输出: 0 0 0 0 0 0 0 0 0 0

    // 内存释放
    free(p);
    p = NULL; // 防止野指针
}

// 功能等价说明:
// 可以理解为: calloc = malloc + memset(0)

// #########################################################################
// 2.动态内存函数 - (4):realloc (Re-Allocation)
// #########################################################################

#include <stdlib.h> // realloc 函数所在的头文件

/*
 * 函数：realloc
 * 功能：重新分配内存块的大小（内存动态调整）
 * 参数：
 *     void* ptr   - 指向之前由malloc、calloc或realloc分配的内存块的指针
 *                  - 如果是空指针，则行为类似于malloc（新建分配）
 *     size_t size - 内存块的新大小，以字节为单位（希望调整成的目标大小）
 *                  - size_t 是无符号整数类型
 * 返回值：
 *     C90 (C++98) 标准:
 *         - 成功: 返回指向重新分配的内存块起始位置的void*类型指针
 *         - 失败: 返回空指针(NULL)，原内存块保持不变
 *
 *     C99/C11 (C++11) 标准:
 *         - 成功: 返回指向重新分配的内存块起始位置的void*类型指针
 *         - 失败: 返回空指针(NULL)
 *         - size为0时: 返回空指针(ptr被释放)
 * 注意事项：
 *     1. 如果ptr是空指针: 函数行为类似于malloc,分配新内存块
 *     2. 如果size为零: 释放ptr指向的内存,返回空指针
 *     3. 内存块内容会保留到新旧尺寸中较小的那个值(数据保护)
 *     4. 如果新尺寸更大,新增部分的值是不确定的(需要手动初始化)
 *     5. 函数可能将内存块移动到新位置(地址可能改变)
 *     6. 如果分配失败,返回空指针,原内存块不会被释放(仍然有效)
 *     7. 必须使用临时变量接收返回值,防止内存泄漏
 */

void realloc_basic_example()
{
    // 初始分配40字节（10个int）
    int *p = (int *)malloc(40);
    printf("原始内存地址: %p\n", p);

    if (p == NULL)
    {
        printf("内存分配失败: %s\n", strerror(errno));
        return;
    }

    // 使用分配的内存
    int i = 0;
    for (i = 0; i < 10; i++)
    {
        *(p + i) = i + 1; // 填充测试数据 1-10
    }

    printf("\n");
    printf("空间不够用了,需要追加40个字节...\n");

    // 错误做法：直接使用原指针接收
    // p = (int*)realloc(p, 80);
    // 问题：如果申请失败返回NULL,会导致原40字节内存泄漏

    // 正确做法：使用临时指针接收
    int *ptr = (int *)realloc(p, 80); // 扩展到80字节（20个int）
    printf("重新分配后的内存地址: %p\n", ptr);

    if (ptr != NULL)
    {
        p = ptr; // 只有成功时才更新原指针
        printf("realloc成功,内存地址%s\n", (p == ptr) ? "发生变化" : "未发生变化");
    }
    else
    {
        printf("realloc失败,保持原内存块\n");
    }

    // 验证数据完整性：重新分配后前40字节数据应该保持不变
    // (int*)realloc(p,80) 这80个空间前40个还是 1 2 3 4 5 6 7 8 9 10
    printf("重新分配后的数据内容: ");
    for (i = 0; i < 10; i++)
    {
        printf("%d ", *(p + i));
    }

    // 清理内存
    free(p);
    p = NULL;
}

// realloc 的两种可能情况说明:
// 情况1：原内存块后面有足够空间
//   - 这个40个字节的空间,后面40个字节的空间没有被使用,正好40+40
//   - realloc直接扩展原内存块,返回相同地址
//
// 情况2：原内存块后面空间不足
//   - 当后面的剩余空间不够40个字节
//   - realloc会在堆区中找到80字节的新空间
//   - 把原40个字节内容拷贝到新空间
//   - 释放旧的空间,返回新的80个字节的首地址

// 性能注意事项:
// 如果频繁的申请和释放空间
// 会导致内存碎片化,降低效率
// 解决方案:使用内存池技术

void test()
{
    int input, n;
    int count = 0;
    int *numbers = NULL;      // 初始为空指针
    int *more_numbers = NULL; // 临时指针,用于安全接收realloc结果

    // 动态数组构建循环
    do
    {
        printf("请输入一个整数值 (0 结束): ");
        scanf("%d", &input);
        count++; // 元素计数增加

        // 动态调整内存大小：每次增加一个int的空间
        more_numbers = (int *)realloc(numbers, count * sizeof(int));

        if (more_numbers != NULL)
        {
            // 分配成功：更新主指针并存储新值
            numbers = more_numbers;
            numbers[count - 1] = input; // 在新增位置存储输入值
        }
        else
        {
            // 分配失败：清理内存并报错
            free(numbers);
            puts("内存分配错误");
            return;
        }
    } while (input != 0); // 输入0时结束循环

    // 输出所有存储的数字
    printf("输入的数字列表: ");
    for (n = 0; n < count; n++)
    {
        printf("%d ", numbers[n]);
    }

    // 最终内存释放
    free(numbers);
    // 注意：numbers不需要置NULL，因为函数结束
}
