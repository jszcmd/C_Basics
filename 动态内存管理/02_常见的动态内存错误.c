// #########################################################################
// 3.常见的动态内存错误
// #########################################################################

// -------------------------------------------------------------------------
// (1) 对NULL指针的解引用操作
// -------------------------------------------------------------------------
// 错误原因：未检查malloc返回值就直接使用,如果分配失败返回NULL,解引用会导致程序崩溃

#include <stdio.h>
#include <errno.h>  // errno变量的使用
#include <string.h> // strerror函数的头文件
#include <stdlib.h> // malloc

void test()
{
    int *p = (int *)malloc(40);
    *p = 20; // 危险：如果p的值是NULL,就会有问题 - 未定义行为
    free(p);
}

// 可用的解决方法:始终检查malloc返回值
int main1()
{
    int *p = (int *)malloc(40);
    printf("分配的内存地址: %p\n", p);
    if (p == NULL) // 必须进行空指针检查
    {
        printf("内存分配失败: %s\n", strerror(errno));
        return 1; // 分配失败时及时返回
    }
    // 只有确认分配成功后才能安全使用
    *p = 20;
    printf("成功设置值: %d\n", *p);

    free(p);
    p = NULL;
    return 0;
}

// -------------------------------------------------------------------------
// (2) 对开辟空间的越界访问
// -------------------------------------------------------------------------
// 错误原因:访问超出分配范围的内存区域,导致缓冲区溢出

#include <stdio.h>
#include <errno.h>  // errno变量的使用
#include <string.h> // strerror函数的头文件
#include <stdlib.h> // malloc

int main2()
{
    int *p = (int *)malloc(40); // 分配40字节 = 10个int元素
    if (p == NULL)
    {
        printf("内存分配失败: %s\n", strerror(errno));
        return 1;
    }
    // 分配内存成功
    int i = 0;
    // 错误:我们访问到了第11个int,但是我们分配的只有10个int
    // 循环条件i<=10导致越界访问,这是常见的缓冲区溢出错误
    for (i = 0; i <= 10; i++)
    {
        p[i] = i;
        printf("设置 p[%d] = %d\n", i, p[i]); // i=10时发生越界
    }

    free(p);
    p = NULL;
    return 0;
}

// 正确的边界控制：
int main_correct2()
{
    int *p = (int *)malloc(40); // 10个int
    if (p == NULL)
    {
        printf("内存分配失败: %s\n", strerror(errno));
        return 1;
    }

    int i = 0;
    // 正确：严格控制在分配的空间范围内
    for (i = 0; i < 10; i++)
    { // i < 10，不会越界
        p[i] = i;
    }

    free(p);
    p = NULL;
    return 0;
}

// -------------------------------------------------------------------------
// (3) 对非动态开辟的内存使用free释放
// -------------------------------------------------------------------------
// 错误原因：free只能用于释放堆内存,对栈变量使用会导致未定义行为

#include <stdio.h>
#include <stdlib.h>

int main3()
{
    int a = 10;  // 栈上分配的变量
    int *p = &a; // 指向栈内存的指针

    printf("变量a的值: %d, 地址: %p\n", a, &a);
    printf("指针p指向的值: %d, 地址: %p\n", *p, p);

    // .... 代码

    free(p); // 错误：这样是错了,不能运行;
    // p所指向的空间不是动态开辟的,它所指向的是一块栈区的空间;
    // 栈内存由系统自动管理，不能手动free

    p = NULL;
    return 0;
}

// 正确做法：只对动态分配的内存使用free
int main_correct3()
{
    int a = 10;                          // 栈变量 - 自动管理
    int *p = (int *)malloc(sizeof(int)); // 堆变量 - 手动管理

    if (p != NULL)
    {
        *p = 20;
        free(p); // 正确：只释放动态分配的内存
        p = NULL;
    }

    return 0;
}

// -------------------------------------------------------------------------
// (4) 使用free释放一块动态开辟内存的一部分
// -------------------------------------------------------------------------
// 错误原因:free必须传入malloc返回的原始指针,不能是中间某个位置

#include <stdio.h>
#include <errno.h>  // errno变量的使用
#include <string.h> // strerror函数的头文件
#include <stdlib.h> // malloc

int main4()
{
    int *p = (int *)malloc(40); // 分配10个int的空间
    if (p == NULL)
    {
        printf("内存分配失败: %s\n", strerror(errno));
        return 1;
    }

    // 使用
    int i = 0;
    for (i = 0; i < 10; i++)
    {
        *p = i;
        p++; // 错误:这里的p改变了,不再指向起始位置
    }

    // 释放
    free(p); // 错误：这个时候的p已经超过了我们申请的空间了;
    // 改成for (i=0;i<5;i++)
    // 我们只释放了一部分,要释放,我们需要全部释放;
    // free必须从原始起始地址开始释放整个内存块

    p = NULL;

    // 程序会报错：invalid pointer
    return 0;
}

// 怎么完善上面的代码
// 解决方案：保持原始指针不变,使用指针运算或数组下标访问
int main_correct4()
{
    int *p = (int *)malloc(40);
    // 注意：这里用int* const p也是不行的,下面的 p = NULL; 就用不了;

    if (p == NULL)
    {
        printf("内存分配失败: %s\n", strerror(errno));
        return 1;
    }

    // 使用
    int i = 0;
    for (i = 0; i < 10; i++)
    {
        *(p + i) = i + 1; // 正确：不改变p,或者使用p[i];
        // 通过指针算术访问元素，但保持p指向起始位置
    }

    // 释放
    free(p); // 正确：使用原始指针释放整个内存块
    p = NULL;
    return 0;
}

// -------------------------------------------------------------------------
// (5) 对同一块动态内存多次释放
// -------------------------------------------------------------------------
// 错误原因:重复释放同一块内存是严重错误,称为double-free

#include <stdio.h>
#include <errno.h>  // errno变量的使用
#include <string.h> // strerror函数的头文件
#include <stdlib.h> // malloc

int main5()
{
    int *p = (int *)malloc(40);
    if (p == NULL)
    {
        printf("内存分配失败: %s\n", strerror(errno));
        return 1;
    }

    // 使用内存...
    *p = 100;
    printf("设置的值: %d\n", *p);

    free(p); // 第一次释放：这个时候以p开头的一块空间已经还给操作系统了

    // 但是p还是存储的地址,此时的p就是一个野指针(悬垂指针)
    printf("释放后p的地址: %p (野指针)\n", p);

    // ....
    free(p); // 错误：再次释放,会报错 - double free检测
    // ....

    return 0;
}

// 改进方法:释放后立即置空指针,避免野指针
int main_correct5()
{
    int *p = (int *)malloc(40);
    if (p == NULL)
    {
        printf("内存分配失败: %s\n", strerror(errno));
        return 1;
    }

    // 使用内存...
    *p = 100;

    free(p);  // 第一次释放
    p = NULL; // 关键:立即置为NULL,避免野指针

    free(p); // 安全:free(NULL);什么也不干;
    // free(NULL)是标准允许的安全操作,不会产生任何效果

    // ....
    return 0;
}

// -------------------------------------------------------------------------
// (6) 动态内存开辟忘记释放(内存泄漏)
// -------------------------------------------------------------------------
// 错误原因:分配内存后没有在适当的时候释放,导致内存资源浪费

#include <stdio.h>
#include <stdlib.h>

// 情况1：函数中途返回导致内存泄漏
// 如果输入的是5,那么就会有内存泄露的问题;
// 只是这个程序找不到了这块内存了;操作系统还是会回收的
// 内存泄漏:你向内存申请了一块空间,你用完了,但是没有还回去,
//      你不用,也不还;这块空间对系统来说,就是内存泄漏了;
void test()
{
    int *p = (int *)malloc(100); // 分配100字节

    // ...代码
    int flag = 0;
    printf("输入一个数字: ");
    scanf("%d", &flag);

    if (flag == 5)
    {
        return; // 危险：直接返回，未释放内存！
        // 当输入5时，p指向的100字节内存就泄漏了
    }

    // ... 代码

    free(p); // 只有非5输入时才会执行到这里
    p = NULL;
}

// 情况2：指针传递后忘记释放
// 开辟100个字节的空间,自己用完之后,把地址给别人用;
int *test2()
{
    int *p = (int *)malloc(100); // 在函数内分配内存
    if (p == NULL)
        return p; // 分配失败返回NULL
    // ...
    // 初始化或其他操作
    return p; // 返回动态内存指针给调用者 - 转移内存所有权
}

int main()
{
    int *res = test2();
    // 交给main使用了,使用完之后,但是没有释放;
    // 问题：获得内存所有权后忘记释放，导致内存泄漏

    if (res != NULL)
    {
        // 使用res指向的内存...
        *res = 42;
        printf("使用的值: %d\n", *res);
        // 应该在这里释放：free(res); res = NULL;
    }

    return 0;
}
