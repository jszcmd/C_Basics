// #########################################################################
// 5.柔性数组 (Flexible Array Member)
// #########################################################################

#include <stdio.h>
#include <stdlib.h>

// C99中,结构体的最后一个元素是未知大小的数组,这就叫做柔性数组成员
// 例如:
typedef struct st_type
{
    int i;
    int arr[0]; // 柔性数组成员
    // 这个0表示这个数组不知道有几个元素
    // 如果编译器会报错,那么就写成 int a[];
} type_a;

// -------------------------------------------------------------------------
// 1.柔性数组的特点:
// -------------------------------------------------------------------------

// 结构体中柔性数组成员前面必须至少有一个其他成员;
// sizeof返回的这种结构大小不包括柔性数组的内存;
// 包含柔性数组的成员结构体用malloc()函数进行内存动态分配,并且分配的内存应该大于结构体的大小,以适应柔性数组的预期大小

// -------------------------------------------------------------------------
// 2.柔性数组的使用:
// -------------------------------------------------------------------------

void test_flexible_array()
{
    printf("柔性数组大小: %zu\n", sizeof(type_a)); // 4 - 只计算固定成员大小

    // type_a s; // 这样创建的时候,这个结构体变量s就是4个字节的变量,是没有给arr开辟空间的

    // 柔性数组的使用 - 一次性分配所有内存
    type_a *ps = (type_a *)malloc(sizeof(type_a) + 40); // 开辟44个字节,40个空间是给arr开辟的
    if (ps == NULL)
    {
        printf("内存分配失败\n");
        return;
    }

    // 初始化结构体成员
    ps->i = 100;

    // 使用柔性数组
    int i = 0;
    for (i = 0; i < 10; i++)
    {
        ps->arr[i] = i + 1; // 访问柔性数组元素
    }

    // 打印数组内容
    printf("柔性数组内容: ");
    for (i = 0; i < 10; i++)
    {
        printf("%d ", ps->arr[i]);
    }
    printf("\n");

    // 动态扩容 - 使用realloc调整大小
    printf("数组扩容...\n");
    type_a *ptr = (type_a *)realloc(ps, sizeof(type_a) + 80); // 扩展到80字节
    if (ptr != NULL)
    {
        ps = ptr; // 更新指针指向新内存
        ptr = NULL;

        // 使用扩容后的空间
        for (i = 10; i < 20; i++)
        {
            ps->arr[i] = i + 1; // 继续填充数据
        }

        printf("扩容后数组内容: ");
        for (i = 0; i < 20; i++)
        {
            printf("%d ", ps->arr[i]);
        }
        printf("\n");
    }

    // 使用完了,释放空间 - 只需要一次free
    free(ps);
    ps = NULL;
    printf("内存已释放\n");
}

// -------------------------------------------------------------------------
// 传统方法对比:
// -------------------------------------------------------------------------

// 也把所有的数据放入到堆区里面;
// 这样arr指向的空间也可大可小
struct s
{
    int n;
    int *arr; // 指针成员,需要二次分配
};

void test_traditional_method()
{
    // 第一次分配：结构体本身
    struct s *ps = (struct s *)malloc(sizeof(struct s));
    if (ps == NULL)
        return;

    ps->n = 100;

    // 第二次分配：数组成员
    ps->arr = (int *)malloc(40); // 第二次malloc
    if (ps->arr == NULL)
    {
        free(ps); // 需要手动释放第一次分配的内存
        printf("数组成员内存分配失败\n");
        return;
    }

    // 使用数组成员
    int i = 0;
    for (i = 0; i < 10; i++)
        ps->arr[i] = i + 1;

    printf("传统方法数组内容: ");
    for (i = 0; i < 10; i++)
        printf("%d ", ps->arr[i]);
    printf("\n");

    // 需要扩容 - 对数组单独扩容
    printf("传统方法数组扩容...\n");
    int *ptr = (int *)realloc(ps->arr, 80);
    if (ptr == NULL)
    {
        free(ps->arr); // 需要分别释放
        free(ps);
        printf("扩容失败\n");
        return;
    }

    ps->arr = ptr; // 更新数组指针
    ptr = NULL;

    // 使用扩容后的数组
    for (i = 10; i < 20; i++)
        ps->arr[i] = i + 1;

    // 释放内存 - 需要两次free,顺序很重要
    free(ps->arr); // 先释放数组成员
    free(ps);      // 再释放结构体
    ps = NULL;
    printf("传统方法内存已释放\n");
}

// -------------------------------------------------------------------------
// 3.柔性数组的优势:
// -------------------------------------------------------------------------

/*
 * 上述代码1和代码2可以完成同样的功能，但是方法1的实现有两个好处：
 *
 * 第一个好处是：方便内存释放
 *
 * 如果我们代码是在一个给别人用的函数中，你在里面做了二次内存分配，并把整个结构体返回给用户。
 * 用户调用free可以释放结构体，但是用户并不知道这个结构体内的成员也需要free，所以你不能指望
 * 用户来发现这个事。所以，如果我们把结构体的内存以及其成员要的内存一次性分配好了，并返回给
 * 用户一个结构体指针，用户做一次free就可以把所有的内存也给释放掉。
 *
 * 第二个好处是：这样有利于访问速度。
 *
 * 连续的内存有益于提高访问速度，也有益于减少内存碎片。
 * （其实，我个人觉得也没多高了，反正你跑不了要用做偏移量的加法来寻址）
 */

// -------------------------------------------------------------------------
// 主函数测试:
// -------------------------------------------------------------------------

int main()
{
    printf("=== 柔性数组演示 ===\n");
    test_flexible_array();

    printf("\n=== 传统方法演示 ===\n");
    test_traditional_method();

    printf("\n=== 演示完成 ===\n");
    return 0;
}
